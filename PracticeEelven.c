#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>

//有一个数组,只有一个数字出现一次，求这个数字多少？要求：只能遍历一遍数组
int dd(int arr[], int len){
	int ret = 0;
	for (int i = 0; i < len; i++){
		ret ^= arr[i];
	}
	return ret;
}

int main(){
	int arr[] = { 1, 3, 5, 2, 1, 5, 2 };
	int len = sizeof(arr) / sizeof(arr[0]);
	printf("%d\n", dd(arr, len));
	system("pause");
	return 0;
}


//写一个函数返回参数二进制中 1 的个数
//比如： 15 0000 1111 4 个 1
//程序原型：
int count_one_bits(unsigned int value)
{
	// 返回 1的位数 
}
int count_one_bits(unsigned int value){
 1.	//	int count = 0;
	while (value != 0){
		if (value % 2 == 1){
			count++;
		}
		value = value / 2;
	}
	return count;
}
// 2.//	int count = 0;
//	for (int i = 0; i < 32; i++){
//		if (((value >> i) & 1)){
//			count++;
//		}
//	}
//	return count;
//}
//3.//	int count = 0;
//	while (value != 0){
//		count++;
//		value = value & (value - 1);
//	}
//	return count;
//}
int main(){

	printf("%d\n", count_one_bits(10));
	system("pause");
	return 0;
}





//各个位运算符的用法如下所示：
//（1） | ：按位或，两个数只要有一个是1就是1，例如8 | 5，8的二进制数是00001000，5的二进制数是：00000101，8 | 5的值
//就是00001101，十进制为13，位运算或其实可以看成将两个数不一样的地方和一样的地方提出来，因为1 | 1等于1，
//所以说只提出来了一半，两个1最后成了一个1，所以说只提出来一半
//（2）&：按位与，两个数都为1（真）结果才为1（真），否则为0（假），例如8 & 5，8的二进制数是00001000，5的二进制
//数是：00000101，8 & 5的值为00000000，位运算符&其实可以看成是将两个数一样的地方提出来一半，和或运算一样
//1 & 1之后就只剩下了一个1，对于两个数来说，也只算提出来了一半
//（3）~:按位取反：就是遇到1将他变成0；把0变成1就好，计算一个负数的十进制数是多少时，就将他按位取反再加1转化
//成十进制就好
//（4）^ : 按位异或：两个数不一样就为1，否则为0，例如8 ^ 5，8的二进制数是00001000，5的二进制数是：00000101，8 ^ 5的
//值就是00001101，00001100, 位运算符异或可以看成是将两个数不一样的地方提出来。
//（5） << 按位左移：将二进制数向左移右值（位运算符右边的数）数的位，右边（低位）补0，相当于将原数乘2，对几进制
//数操作就相当于乘以多少进制，如果对八进制数操作就相当于乘以8，对十六进制数操作就相当于乘以16，例如17
//的二进制数是00010001，左移之后：00100010，换算成十进制数就是34，相当于17 * 2，17的八进制是021，左移之后 : 210
//左移一位之后相当与乘以8，210的十进制数就是136等于17 * 8。
//（6） >> 按位右移：将二进制数向右移右值（位运算符右边的数）数的位，左边补符号位，相当与除法，和按位左移一样，是
//多少进制就除以多少进制，存在整除问题，结果向零靠近





